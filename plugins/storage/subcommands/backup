#!/usr/bin/env bash
set -eo pipefail; [[ $DOKKU_TRACE ]] && set -x
source "$PLUGIN_CORE_AVAILABLE_PATH/common/functions"
source "$PLUGIN_AVAILABLE_PATH/storage/functions"

storage_backup_cmd() {
  declare desc="Backup bind-mount(s)"
  local cmd="storage:backup"
  local passed_phases=(deploy run)
  verify_app_name "$2" && local APP="$2"

  # multiple binds from the same path can be ignored so we use the host mount path
  # the host bind path will be the path within the backup
  BIND_MOUNTS=$(get_bind_mounts "$(get_phase_file_path "$passed_phases")")
  LOCATIONS=""
  for VOLUME_BIND in ${BIND_MOUNTS}; do
    HOST_LOCATION=$(echo $VOLUME_BIND | sed -e "s|\:.*||")
    # ignore /tmp as it can break the backup and should be superfluous
    if [[ ${HOST_LOCATION} != /tmp ]]; then
      LOCATIONS="${LOCATIONS} ${HOST_LOCATION}"
    fi
  done

  # get unique host bind locations; support host path to multiple binds
  LOCATIONS=$(echo ${LOCATIONS} | tr ' ' '\n' | sort -u)

  # create a hash for the tmp filename (app locations)
  HASH=$(echo ${1}${LOCATIONS} | md5sum | sed -e "s| *- *||")

  # create backup file
  rm -rf /tmp/${HASH}.tar.gz
  tar -czf /tmp/${HASH}.tar.gz $LOCATIONS
  # TODO display why it is empty.. i.e. only mount(s) /tmp

  # try 3rd party backup; else stdout
  # TODO implement 3rd party
  cat /tmp/${HASH}.tar.gz

  # remove the backup file
  rm -f /tmp/${HASH}.tar.gz
}

storage_backup_cmd "$@"
